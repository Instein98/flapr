import os
import sys
import json
import argparse
from datetime import datetime

from yaml import parse

patchesInfoDir = 'praprPatchesInfo'
flSusListDir = '../sbfl/sbflResult/'
simulateReportDir = 'simulateReport'

fls = ["Ample", "Anderberg", "Dice", "Dstar2", "ER1a", "ER1b", "ER5c", "Euclid", "Goodman", 
        "GP02", "GP03", "GP13", "GP19", "Hamann", "Hamming", "Jaccard", "Kulczynski1", 
        "Kulczynski2", "M1", "M2", "Ochiai", "Ochiai2", "Overlap", "rensenDice", 
        "RogersTanimoto", "RussellRao", "SBI", "SimpleMatching", "Sokal", "Tarantula", 
        "Wong1", "Wong2", "Wong3", "Zoltar"]

def getProjHavingCorrectPatch():
    res = []
    for pid in os.listdir(patchesInfoDir):
        pidPath = os.path.join(patchesInfoDir, pid)
        if not os.path.isdir(pidPath):
            continue
        for jsonFile in os.listdir(pidPath):
            if not jsonFile.endswith('.json'):
                continue
            jsonFilePath = os.path.join(pidPath, jsonFile)
            with open(jsonFilePath, 'r') as file:
                if '"isCorrect": true' in file.read():
                    bid = jsonFile[:-5]
                    res.append(pid + '-' + bid)
    return res

def readSusList(susListPath: str):
    res = []
    firstLine = True
    with open(susListPath, 'r') as file:
        for line in file:
            if firstLine:
                firstLine = False
                continue
            if ', ' in line:
                location = line.strip().split(', ')[0]
                res.append(location)
    return res

def readPatchInfoDict(pid: str, bid: str):
    # read the patches information
    patchInfoPath = os.path.join(patchesInfoDir, pid, bid + '.json')
    if not os.path.isfile(patchInfoPath):
        err('File not found: {}'.format(patchInfoPath))
        return None
    with open(patchInfoPath, 'r') as file:
        patchesDict = json.load(file)
    
    # sort the patches (Assume for each location, correct is generated before plausible patches and implausible patches)
    # For each location, sort the correct before plausible, plausible before implausible.
    for location in patchesDict:
        patchList = patchesDict[location]
        correctPatchList = []
        plausiblePatchList = []  # plausible but not correct
        for patch in patchList:
            if patch['isCorrect'] == True:
                correctPatchList.append(patch)
                continue
            elif patch['isPlausible'] == True:
                plausiblePatchList.append(patch)
                continue
        for patch in plausiblePatchList: 
            patchList.remove(patch)
            patchList.insert(0, patch)
        for patch in correctPatchList:
            patchList.remove(patch)
            patchList.insert(0, patch)
        patchesDict[location] = patchList
    return patchesDict

def sortPatchesByFL(pid: str, bid: str, flName: str, patchesDict: dict):
    res = []  # list of the patches generated using the FL order.

    # read the suspicious list
    susListPath = os.path.join(flSusListDir, pid, bid, flName + '.csv')
    if not os.path.isfile(susListPath):
        err('File not found: {}'.format(susListPath))
        return None
    susList = readSusList(susListPath)
    
    ## secondly sort the locations according to the fl suspicious list
    for location in susList:
        if location in patchesDict:
            res.extend(patchesDict[location])
    return res

def orderOfCorrectPlausible(patchOrderedList: list):
    res = []
    for patch in patchOrderedList:
        if patch['isCorrect'] == True:
            res.append(1)
        elif patch['isPlausible'] == True:
            res.append(0)
    return res

def timeToGenFirstCorrect(patchOrderedList: list):
    res = 0
    for patch in patchOrderedList:
        if patch['isCorrect'] == False:
            res += patch['validationTime']
        else:
            return res
    return -1  # -1 means no correct patch is found

def numOfPlausibleBeforeCorrect(simplifiedOrder):  # the argument is a list of 0s and 1s generated by orderOfCorrectPlausible()
    res = 0
    for x in simplifiedOrder:
        if x == 1:
            return res
        else:
            res += 1
    return -1  # -1 means no correct patch is found

def generateSummary(pid: str, bid: str):
    log('===== Processing {}-{} ====='.format(pid, bid))
    text = 'FL, Plausible&Correct Distribution, #Plausible before Correct, Time before First Correct \n'
    patchInfoDict = readPatchInfoDict(pid, bid)
    if patchInfoDict == None:
        err('Failed to read patches info for {}-{}, skipping'.format(pid, bid))
        return
    for fl in fls:
        patchOrderedList = sortPatchesByFL(pid, bid, fl, patchInfoDict)
        if patchOrderedList == None:
            err('Failed to sort patches according to the FL {0}, skipping {0}'.format(fl))
            continue
        distribution = orderOfCorrectPlausible(patchOrderedList)
        numPBeforeC = numOfPlausibleBeforeCorrect(distribution)
        timeForFirstC = timeToGenFirstCorrect(patchOrderedList)
        text += '{}, {}, {}, {}\n'.format(fl, distribution, numPBeforeC, timeForFirstC)
    os.makedirs(os.path.join(simulateReportDir, pid), exist_ok=True)
    with open(os.path.join(simulateReportDir, pid, bid + '.report'), 'w') as file:
        file.write(text)

def main():
    for projId in getProjHavingCorrectPatch():
        tmp = projId.split('-')
        pid = tmp[0]
        bid = tmp[1]
        generateSummary(pid, bid)

def err(msg: str):
    print('[ERROR]({}) {}'.format(datetime.now().strftime('%Y/%m/%d %H:%M:%S'), msg))

def warn(msg: str):
    print('[WARNING]({}) {}'.format(datetime.now().strftime('%Y/%m/%d %H:%M:%S'), msg))

def log(msg: str):
    print('[INFO]({}) {}'.format(datetime.now().strftime('%Y/%m/%d %H:%M:%S'), msg))

if __name__ == '__main__':
    # parser = argparse.ArgumentParser()
    # parser.add_argument('command')
    # parser.parse_args(sys.argv[1:])
    # args = parser.parse_args(['xxx'])
    # print(vars(args))
    # generateSummary()
    # print(getProjHavingCorrectPatch())
    main()